[toc]

# 语法知识

## NSString

```objc
// 创建NSString
NSString *str = @"string";
str = [NSString new];
str = [NSString stringWithFormat:@"string %d", 1];
// 字符串和整数转换 int为例 float等同理
NSString *str = @"123";
int num = [str intValue];
str = [NSString stringWithFormat:@"%d", 1];

```

## 二维数组

```objc
NSMutableArray *array;
array = [[NSMutableArray alloc] init];
for (NSInteger row = 0; row < colNum; row++) {
  NSMutableArray *arrayValue = [[NSMutableArray alloc] init];
  for(NSInteger col = 0; col < rowNum; col++) {
    [arrayValue addObject:@"11"];
  }
  [self.array addObject:arrayValue];
}
```



## 关键字

1. `atomic` 和 `nonatomic` 关键字

   `atomic` 为**默认关键字**，能够保证 setter 和 getter 方法的完整性，`nonatomic` 能够提升性能，但不能保证原子性，两者都是线程不安全的。`atomic` 其底层原理就是对 setter 和 getter 方法进行加锁操作以保存存取值的安全性和完整性，安全性体现在 setter 和 getter 方法内部的安全性，因为加了锁所以导致性能消耗。详见<https://juejin.cn/post/6844904072475049992>

# UIKit

## UITableView

### 使用方法：

1. 在 ViewController.h 文件中实现 UITableViewDelegate, UITableViewDataSource 两个 delegate

```objc
#import <UIKit/UIKit.h>

@interface ViewController : UIViewController<UITableViewDelegate, UITableViewDataSource>
@end
```

2. 在 ViewController.m 文件中给要用的UITableView设置self delegate 这样子就会有代码提示

```objc
self.tableView.delegate = self;
self.tableView.dataSource = self;
```

3. 实现协议的一些方法，如 numberOfSectionsInTableView: ,  tableView: cellForRowAtIndexPath

```objc
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return self.array.count;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return [self.array[section] count];
}
```

## ViewController 间页面传值

### 方法一：使用 Delegate

1. 在传值页面 ` NewViewContoller` 的 `NewViewController.h` 中创建 `NewViewControllerDelegate` 代理协议，其包含一个未实现的 `sendValue` 方法用于传递值。

```objc
@protocol NeWViewControllerDelegate <NSObject>

@required

- (void)sendValue: (NSString *) string;

@end
```

2. 给传值页面 ` NewViewContoller` 添加一个对象属性，该对象实现了 `NeWViewControllerDelegate` 协议。传值页面其实就是委托方，它要委托代理方去完成一个功能，这个代理方必须实现委托方规定的协议。使用 `weak` 关键字的原因为防止泄漏，因为第一个页面（接收页面）要设置委托方的代理方为自己: `newView.delegate = self;`。

```objc
@interface NewViewController : UIViewController
@property (strong,nonatomic) NSString *str;
// 
@property (nonatomic, weak, nullable) id <NeWViewControllerDelegate> delegate;
@end
```

3. 在委托方也就是传值页面调用 `sendValue` 方法来设定需要传递的值。

```objc
@implementation
- (void)clickButton {
    [self.navigationController popViewControllerAnimated: YES];
    NSString* str = self.textView.text;
    if (str.length > 0) {
        // 先判断实现代理类有没有这个方法
        if ([self.delegate respondsToSelector:@selector(sendValue:)]) {
            [self.delegate sendValue:str];
            self.sendValueBlock(str);
        }
    }
}

@end
```

4. 代理方实现协议，完成所需要的功能

```objc
# ViewController.m
@interface ViewController ()<NeWViewControllerDelegate>

@end
  
@implementation ViewController
// 跳转到传值页面的函数
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    self.indexPath = indexPath;
    NewViewController *newView = [[NewViewController alloc]init];
    // - MARK: 从前往后传值
    newView.str = self.array[self.indexPath.section][self.indexPath.row];
    newView.delegate = self; // 这句很关键，将第一个页面设为代理方，使其具有处理代理协议的功能
    [self.navigationController pushViewController:newView animated:YES];
}
// 传值函数
- (void)sendValue:(NSString *)string
{
    self.array[self.indexPath.section][self.indexPath.row] = string;
    [self.tableView reloadRowsAtIndexPaths:@[self.indexPath] withRowAnimation:UITableViewRowAnimationLeft];
}
@end
```



### 方法二：使用 Block

1. 在传值页面 ` NewViewContoller` 的 `NewViewController.h` 中声明一个 `Block`。

```objc
@interface NewViewController: UIViewController
// 声明
@property (nonatomic, copy) sendValueByBlock _Nullable sendValueBlock;

@end
```

2. 在要用到值的地方调用 `sendValueBlock`

```obj
- (void)clickButton
{
    [self.navigationController popViewControllerAnimated: YES];
    NSString* str = self.textView.text;
    if (str.length > 0)
    {
        // 先判断实现代理类有没有这个方法
        if ([self.delegate respondsToSelector:@selector(sendValue:)])
        {
            self.sendValueBlock(str);
        }
    }
}
```

3. 第一个页面实现 `Block`

```objc
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    self.indexPath = indexPath;
    NewViewController *newView = [[NewViewController alloc] init];
    __weak typeof(self) weakSelf = self;
    newView.sendValueBlock = ^(NSString *str) {
        weakSelf.title = str;
    };
    [self.navigationController pushViewController:newView animated:YES];
}
```

以上必须使用 `__weak` 来修饰以防止内存泄漏。
