[toc]



# 进程管理

## 进程与线程的区别

- 拥有资源：进程（Process）是系统进行资源分配和调度的基本单位，线程不拥有资源，可以访问隶属进程的资源
- 调度：线程（Thread）是CPU调度和分派的基本单位；在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
- 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
- 通信：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

## 进程的状态

<img src="https://camo.githubusercontent.com/0398c2bace5b1b0695f5a34f6cfedf6e358db565408abc83dd161de71d3bfec8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50726f6365737353746174652e706e67" alt="img" style="zoom:67%;" />

- 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源
- 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数
- 阻塞状态： 进程等待某种条件，在条件满足之前无法执行

只有就绪和运行是双向的

## 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

### 1. 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

**1.1 先来先服务 first-come first-serverd（FCFS）**

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

**1.2 短作业优先 shortest job first（SJF）**

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

**1.3 最短剩余时间优先 shortest remaining time next（SRTN）**

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

### 2. 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

**2.1 时间片轮转**

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

[![img](https://camo.githubusercontent.com/a87daa8201015ff54a213d9ea95c1e49e7eec447938c441dd0247e80b18eaa05/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)](https://camo.githubusercontent.com/a87daa8201015ff54a213d9ea95c1e49e7eec447938c441dd0247e80b18eaa05/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)



**2.2 优先级调度**

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

**2.3 多级反馈队列**

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

[![img](https://camo.githubusercontent.com/c20fd7a3268ebc4ef0bce390344de2c5358392ecef2413d849c3095e21047980/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67)](https://camo.githubusercontent.com/c20fd7a3268ebc4ef0bce390344de2c5358392ecef2413d849c3095e21047980/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67)



### 3. 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

## 进程同步

### 1. 临界区

对临界资源进行访问的那段代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```
// entry section
// critical section;
// exit section
```

### 2. 同步与互斥

- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

### 3. 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。

### 4. 管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

## 经典同步问题

### 1. 生产者-消费者问题

**问题**

一组生产者进程和一组消费者进程共享一个初始为空，大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待，只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息或一个消费者从中取出消息。

**关系**

生产者和消费者对缓冲区访问都是互斥访问（生产者之间互斥，避免数据覆盖；消费者之间互斥，避免数据重复消费；生产者和消费者之间互斥）。同时，生产者和消费者之间也是相互协作的关系，只有生产者生产之后，消费者才能消费，属于同步关系。

**信号量设置**

设置两个同步信号量：full=0，表示初始满缓冲区个数为0个，empty=n，表示初始空缓冲区个数为n个。

设置一个互斥信号量：mutex，初值为1，用于控制对缓冲区的互斥访问。

**代码**

```c
semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0;
producer(){
    while(1){
        produce an item in nextp;
        p(empty);	//只在有空缓冲区时，才进行下一步
        p(mutex);	//有空缓冲区的前提下，判断是否消费者正在消费
        add nextp to buffer;
        v(mutex);	
        v(full);
    }
}
consumer(){
    while(1){
        p(full);	//只在有满缓冲区时，才进行下一步
        p(mutex);	//在有满缓冲区的前提下，
        remove an item from buffer;
        v(mutex);
        v(empty);
        consume the item;
    }
}
```

**变体问题描述**

桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等吃盘子中的橘子，女儿专等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈才可向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出。

**关系分析**

每次只能向盘子中放入一个水果，爸爸和妈妈是互斥关系。爸爸和女儿，妈妈和儿子是同步关系，而且这两对进程必须连起来，儿子和女儿之间没有互斥或同步关系，因为他们是选择条件执行，不可能并发。

**信号量设置**

设置两个同步信号量：apple=0，用于协调爸爸和女儿，orange=0，用于协调妈妈和儿子

设置一个互斥信号量：plate=1，用于保证爸爸和妈妈互斥访问盘子

**代码示例**

```c
semaphore plate=1,apple=0,orange=0;
dad(){
    while(1){
        prepare an apple;
        p(plate);
        put the apple on the plate;
        v(apple);
    }
}
mom(){
    while(1){
        prepare an orange;
        p(plate);
        put the orange on the plate;
        v(orange);
    }
}
son(){
    while(1){
        p(orange);
        take an orange from the plate;
        v(plate);
        eat the orange;
    }
}
daughter(){
    while(1){
        p(apple);
        take an apple from the plate;
        v(plate);
        eat the apple;
    }
}
```

这是生产者-消费者模型的升级版，本质上是两组生产者和消费者。问题的关键是生产者之间的互斥，生产者和消费者之间的同步连续执行。

比如爸爸和女儿在生产之后都没有立即释放盘子，而是释放对应的水果，这样儿子和女儿都可以访问盘子，但是只有有相应水果的消费者才可以顺利进行消费，然后释放盘子。

儿子和女儿访问盘子都没有p(plate)，因为他们不需要对盘子进行互斥访问，两个消费者是选择条件执行。

找到这个关键点即可。

### 2. 读者-写者问题

**问题**

有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时，不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件进行读操作；②只允许一个写者向文件中写信息；③任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出。

**关系**

读者和写者是互斥的，写者和写者也是互斥的，但是读者和读者不存在互斥问题。

写者比较好处理，和任何进程都是互斥的，用互斥信号量的p操作和v操作即可解决。读者的问题比较复杂，需实现与写者互斥的同时，实现与其他读者的同步。

可以引入一个计数器（**普通变量，而非记录型信号量，也不是整型信号量，只用于统计读者进程数量**），用于记录当前读者的数量，如果读者数为0，则需要判断是否可以互斥访问，如果读者数大于0，则说明当前不存在写者，可以直接访问。

但是对于计数器的修改也需要互斥进行，所以需要额外引入一个互斥信号量，用户保护计数器的修改。

**信号量设置**

设置两个互斥信号量：

mutex=1用于实现计数器（普通变量）的修改，

rw=1用于实现读者和写者对文件的互斥访问

**代码**

```c
int count=0;
semaphore mutex=1;
semaphore rw=1;
writer(){
   while(1){
       p(rw);
       writing;
       v(rw);
   }
}
reader(){
    while(1){
        p(mutex);	//对计数器的访问进行互斥
        if(count==0)
            p(rw);	//只在第一个读者申请访问时，判断是否可以互斥访问文件，后面的读者直接数目加一
        count++;
        v(mutex);
        reading;
        p(mutex);
        count--;
        if(count==0)
            v(rw);	//只在最后一个读者读完时释放rw锁
        v(mutex);        
    }
}
```

**算法改进**

当有读者正在访问文件时，如共有写进程请求访问，这时应禁止后续读者的请求，等到已在共享文件的读者执行完毕，立即让写者执行。只有在无写者执行的情况下，才允许读者再次执行。

** 代码示例**

```c
int count=0;
semaphore mutex=1;
semaphore rw=1;
semaphore w=1;
writer(){
    while(1){
        p(w);
        p(rw);
        writing;
        v(rw);
        v(w);
    }
}

reader(){
    while(1){
        p(w);		//只要来了一个写者，后续的读者就会在这里阻塞，当前已经在共享文件执行的进程执行完之后，释放rw，写者执行，然后读者才能继续执行。
        p(mutex);
        if(count==0)
            p(rw);
        count++;
        v(mutex);
        v(w);
        reading;
        p(mutex);
        count--;
        if(count==0)
            v(rw);
        v(mutex);
    }
}
```

这个算法对于写者来说还是不太公平的，如果共享文件已经有很多读者在访问了，这个时候新来的写者必须等这些读者全都运行完了之后才可以访问共享文件。但是这个算法改进了读者一直占用共享文件的问题，只要写者进程到来，就可以占用w，使得后续的读进程被阻塞。

### 3. 哲学家进餐问题

**问题**

张圆桌上，5名哲学家，每两名哲学家之间有一根筷子。哲学家需拿起两根筷子才可以进餐，否则等待。

**关系**

每名哲学家与左右邻居对筷子的访问是互斥的

**思路**

有两种解决办法：

1.同时拿起两根筷子

2.对每个哲学家拿起筷子的动作指定规则，避免饥饿和死锁发生

**信号量设置**

定义互斥信号量数组chopstick[5]={1,1,1,1,1}，用于对5个筷子的互斥访问。哲学家按序编号0-4，哲学家i左边筷子的编号为i，右边筷子的编号为（i+1）%5

**代码**

```c
semaphore chopstick[5]={1,1,1,1,1};
pi(){
    do{
        p(chopstick[i]);
        p(chopstick[(i+1)%5]);
        eat;
        v(chopstick[i]);
        v(chopstick[(i+1)%5]);
        think;
    }while(1);
}
```

这个算法存在一个问题，当5个哲学家都要进餐，并且都拿起了左边的筷子时，所有进程都无法获取右边的筷子，全部阻塞等待其他哲学家释放筷子，造成死锁。

为防止死锁产生，可以加一些限制条件：

①至多运行4名哲学家同时进餐，这个时候即使4个哲学家都拿起了左边的，但是第五根筷子可以被其中一个哲学家拿起，然后正常推进。

②仅当哲学家能够同时拿起左右两根筷子时，才允许他拿起筷子

③对哲学家顺序编号，奇数号先拿左边再拿右边，偶数号相反。

**代码示例**

```c
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex=1;		//保证每次只有一个哲学家能够访问筷子
pi(){
    do{
        p(mutex);		//如果已经有哲学家在访问筷子，则阻塞
        p(chopstick[i]);	//否则直接拿起两根筷子，顺利推进
        p(chopstick[(i+1)%5]);
        v(mutex);
        eat;
        v(chopstick[i]);
        v(chopstick[(i+1)%5]);
        think;
    }while(1);
}
```

**不因为有筷子能拿起就拿起，而考虑能否一次性拿起两根筷子**。这是哲学家进餐问题的关键。

## 进程通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

分为三类：管道、系统IPC（消息队列、共享内存、信号量、信号）、Socket

### 1. 管道

管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。**管道的实质**是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。

```
#include <unistd.h>
int pipe(int fd[2]);
```

它具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用。
- 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；
- 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；

[![img](https://camo.githubusercontent.com/af6ac5de61c835b0fe14c799c244632fa04239ef2ca9421eee543392353297c8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35336364396164652d623061362d343339392d623464652d3766316662643036636466622e706e67)](https://camo.githubusercontent.com/af6ac5de61c835b0fe14c799c244632fa04239ef2ca9421eee543392353297c8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35336364396164652d623061362d343339392d623464652d3766316662643036636466622e706e67)



### 2. FIFO

也称为命名管道，去除了管道只能在父子进程中使用的限制。

```
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

[![img](https://camo.githubusercontent.com/8c4dd36cf4d1509b9c3ae0500085617fee811f7a83602a71e64769753b66b66b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32616335306238312d643932612d343430312d623965632d6632313133656363333037362e706e67)](https://camo.githubusercontent.com/8c4dd36cf4d1509b9c3ae0500085617fee811f7a83602a71e64769753b66b66b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32616335306238312d643932612d343430312d623965632d6632313133656363333037362e706e67)

**匿名管道和命名管道总结：**
 （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。
 （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；命名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

（3）**无名管道阻塞问题：**无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。
 （4）**有名管道阻塞问题：**有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。

### 3. 消息队列

消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。相比于 FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取，比FIFO更有优势。
- 消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。

### 4. 信号量

它是一个计数器，用于为多个进程提供对共享数据对象的访问。



### 5. 共享存储内存

- 允许多个进程共享一个给定的内存空间。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

- 需要使用信号量用来同步对共享存储的访问。

- 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

### 6. 套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。

